"""
N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.
첫째 줄에 자연수 N(1≤N≤100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다.\
다음 줄에는 M(1≤M≤100,000)이 주어진다.
다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231 보다 크거나 같고 231보다 작다.
"""

N=int(input())
A=list(map(int,input().split()))
A=sorted(A)
M=int(input())
B=list(map(int,input().split()))
"""
X=0
Y=0
for i in range(M):
    X=B[i]
    cnt=0
    for j in range(N):
        Y=A[j]
        if Y==X:
            cnt+=1
    if cnt>0:
        print(1)
    else:
        print(0)

"시간 초과"
"""
def search(C):
    global A
    global N
    target=int(C)
    start=0
    end=N-1
    while start<=end:
        mid=(start+end)//2
        if A[mid]==target:
            print(1)
            return 1
        elif A[mid]>target:
            end=mid-1
        else:
            start=mid+1
    print(0)
    return 0
for i in range(M):
    search(B[i])

"""
------------------------
       이진 탐색
------------------------

예를 들어 [4,6,3,8,9,6,4,1,10]
이런 식으로 있는 리스트는 아까 내가 처음에 했던 것처럼 다 돌리는 무식한 방법밖에 없다.
하지만 이것이 정렬된다고 하면 이진 탐색이라는 걸 통해서 검색속도를 엄청나게 줄일 수가 있다.
그러니 저 리스트도 sort()로 정렬해도 된다면, 충분히 가능하다.

이진 탐색의 원리는 리스트를 가운데로 나눈 뒤
찾는 값이 오른쪽이냐 왼쪽이냐 아니면 딱 걸렸냐 이렇게 분류를 계속하는건데
이게 좋은 이유가 뭐냐면
만약에 10000개짜리 리스트 속에서 찾는다고 가정을 했을때
찾는 수가 무엇이 됐든간에 반으로 쪼개서 찾아본뒤 없는 반을 아예 버리기 때문에
5000개는 순식간에 사라져버리고
그 다음에 또 2500개
엄청 빠르게 사라진다
그리고 반을 쪼개는 방법은 당연하지만 리스트 길이의 반을 구해서 그 가운데에 있는 값을 구하고 그 값과 찾는 값을 계속해서 비교해가는거다.

그래서 start는 0, end는 리스트 길이 -1이다.
왜 -1을 하냐면 찾는 방식이 리스트[mid]값으로 하는거다.
이 때 mid는 start와 end를 반으로 나눠 내림한 값이다. (mid=(start+end)//2)
그래서 이렇게 리스트[mid]와 찾는 값을 비교하고,

만약 찾는 값이 리스트[mid]보다 크면 리스트를 반으로 쪼갰을 때 오른쪽에 있다는거고,
만약 찾는 값이 리스트[mid]보다 작으면 리스트를 반으로 쪼갰을 때 왼쪽에 있다는 말이다.
그리고 딱 걸리면 그대로 return을 통해 반환해서 끝내면 된다.

이 작업을 while문으로 반복해야 되는데 점점 반씩 쪼개는 방법은 다음과 같다.
10000개 짜리 리스트를 예로 들었을 때 5000번째 리스트의 값을 구해서 찾는 값과 비교한다.
이 때 당연히 start는 0이고 end는 9999 이다.
그리고 값을 비교한 뒤에 오른쪽에 있으면 5000번째부터 9999번째 자리까지 비교를 시작해야되고
왼쪽에 있으면 0번째부터 4999번째까지 비교를 해야된다.
이러면 감이 왔을텐데 오른쪽에 있으면 end는 그대로 두고 start만 mid+1 을 하면되고
왼쪽에 있으면 start는 그대로 두고 end만 mid-1을 하면 된다.
그래서 while문 안에 if문으로 오른쪽 왼쪽 값만 구분해주고 start와 end, mid를 적절히 다시 선언하면서 구하면 된다.
"""
